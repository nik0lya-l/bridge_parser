<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Крымский мост - статистика</title>
    <script src="https://cdn.plot.ly/plotly-2.18.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        /* Ваши стили остаются без изменений */
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        /* ... остальные стили ... */
    </style>
</head>
<body>
    <!-- Ваша HTML-разметка остается без изменений -->
    <!-- ... -->

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const DATA_URL = "crimea_bridge.csv";

            let allData = [];
            let availableDates = [];
            let currentDate = null;

            const COLORS = {
                cars: "#00B4B4",
                wait: "#FF8C42",
                closed: "#FF6B6B",
                opened: "#51CF66"
            };

            // Новая функция для корректного парсинга даты и времени
            function parseDateTime(dateStr, timeStr) {
                const [day, month, year] = dateStr.split('.');
                const [hours, minutes] = timeStr.split(':');
                
                // Создаем дату в UTC (без учета локального времени браузера)
                const date = new Date(Date.UTC(year, month-1, day, hours, minutes));
                
                // Корректируем на московское время (+3 часа)
                date.setHours(date.getHours() + 3);
                
                return {
                    date: date,
                    hours: parseInt(hours),
                    minutes: parseInt(minutes),
                    timeDecimal: parseFloat(hours) + (parseFloat(minutes) / 60)
                };
            }

            async function loadData() {
                try {
                    const response = await fetch(DATA_URL);
                    if (!response.ok) throw new Error(`Ошибка HTTP! Статус: ${response.status}`);
                    const text = await response.text();
                    return new Promise((resolve, reject) => {
                        Papa.parse(text, {
                            header: true,
                            skipEmptyLines: true,
                            complete: (results) => {
                                const processedData = results.data
                                    .filter(row => row.date && row.time)
                                    .map(row => {
                                        try {
                                            const dt = parseDateTime(row.date, row.time);
                                            
                                            return {
                                                ...dt,
                                                dateStr: row.date,
                                                timeStr: row.time,
                                                to_crimea: row.to_crimea === "Closed" ? "Closed" : 
                                                          row.to_crimea === "Opened" ? "Opened" : 
                                                          parseInt(row.to_crimea) || 0,
                                                from_crimea: row.from_crimea === "Closed" ? "Closed" : 
                                                            row.from_crimea === "Opened" ? "Opened" : 
                                                            parseInt(row.from_crimea) || 0,
                                                to_crimea_wait: parseFloat(row.to_crimea_wait) || 0,
                                                from_crimea_wait: parseFloat(row.from_crimea_wait) || 0,
                                                isBridgeEvent: row.to_crimea === "Closed" || row.to_crimea === "Opened"
                                            };
                                        } catch (e) {
                                            console.error("Ошибка парсинга строки:", row, e);
                                            return null;
                                        }
                                    })
                                    .filter(Boolean);
                                resolve(processedData);
                            },
                            error: reject
                        });
                    });
                } catch (error) {
                    throw error;
                }
            }

            function initAvailableDates(data) {
                const dateSet = new Set();
                data.forEach(item => {
                    // Форматируем дату как yyyy-mm-dd для корректной сортировки
                    const dateStr = item.date.getFullYear() + '-' + 
                                   String(item.date.getMonth() + 1).padStart(2, '0') + '-' + 
                                   String(item.date.getDate()).padStart(2, '0');
                    dateSet.add(dateStr);
                });
                availableDates = Array.from(dateSet).sort();
            }

            function updateDatePicker(dateStr) {
                const dateInput = document.getElementById('date-picker');
                if (dateInput) {
                    dateInput.value = dateStr;
                    if (availableDates.length > 0) {
                        dateInput.min = availableDates[0];
                        dateInput.max = availableDates[availableDates.length - 1];
                    }
                }
            }

            // Остальные функции (updateNavigationButtons, formatDateDisplay, updateMetrics) остаются без изменений
            // ...

            function updateChart() {
                const chartEl = document.getElementById('chart');
                if (!chartEl || !allData || allData.length === 0) return;

                const direction = document.querySelector('input[name="direction"]:checked');
                if (!direction) return;
                
                const directionValue = direction.value;
                const isCurrentDate = currentDate === availableDates[availableDates.length - 1];
                
                // Получаем данные для текущей даты
                const currentDateObj = new Date(currentDate + 'T00:00:00');
                const dataForCurrentDate = allData.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate.getFullYear() === currentDateObj.getFullYear() &&
                           itemDate.getMonth() === currentDateObj.getMonth() &&
                           itemDate.getDate() === currentDateObj.getDate();
                });

                // Сортируем события по времени
                const bridgeEvents = dataForCurrentDate
                    .filter(item => item.isBridgeEvent)
                    .sort((a, b) => a.timeDecimal - b.timeDecimal);

                // Определяем текущий статус моста
                const lastEvent = bridgeEvents[bridgeEvents.length - 1];
                const bridgeStatus = lastEvent ? lastEvent.to_crimea : "Opened";
                const bridgeStatusEl = document.getElementById("bridge-status");
                if (bridgeStatusEl) {
                    bridgeStatusEl.textContent = bridgeStatus === "Closed" ? "Закрыт" : "Открыт";
                    bridgeStatusEl.style.color = bridgeStatus === "Closed" ? COLORS.closed : COLORS.opened;
                }

                // Строим график (остальная часть функции остается без изменений)
                // ...
            }

            // Остальной код инициализации остается без изменений
            // ...

            async function initApp() {
                try {
                    allData = await loadData();
                    if (allData.length === 0) {
                        showError('Данные не загружены или отсутствуют.');
                        return;
                    }
                    
                    initAvailableDates(allData);
                    currentDate = availableDates[availableDates.length - 1];
                    updateDatePicker(currentDate);
                    initControls();
                    updateNavigationButtons();
                    updateChart();
                } catch (error) {
                    showError(`Ошибка загрузки данных: ${error.message}`);
                    console.error(error);
                }
            }

            function showError(message) {
                const errorEl = document.createElement('div');
                errorEl.className = 'error-message';
                errorEl.textContent = message;
                document.body.appendChild(errorEl);
            }

            initApp();
        });
    </script>
</body>
</html>
