<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Крымский мост - статистика</title>
    <!-- Подключаем Plotly.js (актуальная версия) -->
    <script src="https://cdn.plot.ly/plotly-2.18.2.min.js"></script>
    <!-- Подключаем PapaParse для работы с CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .direction-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .direction-options {
            display: flex;
            gap: 15px;
        }
        .date-nav {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .nav-button {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .nav-button:hover:not(:disabled) {
            background-color: #45a049;
        }
        .nav-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #date-picker {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .metrics {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        .metric-card {
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            min-width: 250px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .metric-title {
            font-size: 16px;
            color: #555;
            margin-bottom: 10px;
        }
        .metric-value {
            font-size: 28px;
            font-weight: bold;
            color: #1f77b4;
        }
        .metric-wait {
            color: #ff7f0e;
        }
        #chart {
            height: 550px;
            width: 100%;
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .error-message {
            color: red;
            text-align: center;
            padding: 20px;
            background-color: #ffeeee;
            border-radius: 5px;
            margin: 20px 0;
        }
        .modebar {
            display: none !important;
        }
        .hovertext {
            font-family: Arial, sans-serif !important;
            font-size: 14px !important;
            padding: 8px !important;
            background: rgba(255, 255, 255, 0.95) !important;
            border: 1px solid #ddd !important;
            border-radius: 5px !important;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1) !important;
        }
        .legend-closed {
            background-color: rgba(255, 0, 0, 0.1);
            padding: 2px 5px;
            border-radius: 3px;
        }
        .legend-opened {
            background-color: rgba(0, 255, 0, 0.1);
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Статистика движения по Крымскому мосту</h1>
        <p>Актуальные данные о количестве машин и времени ожидания</p>
    </div>

    <div class="controls">
        <div class="direction-selector">
            <label><strong>Направление движения:</strong></label>
            <div class="direction-options">
                <label>
                    <input type="radio" id="to_crimea" name="direction" value="to_crimea" checked />
                    В Крым
                </label>
                <label>
                    <input type="radio" id="from_crimea" name="direction" value="from_crimea" />
                    Из Крыма
                </label>
            </div>
        </div>

        <div class="date-nav">
            <button class="nav-button" id="prev-date" title="Предыдущий день">←</button>
            <input type="date" id="date-picker" />
            <button class="nav-button" id="next-date" title="Следующий день">→</button>
        </div>
    </div>

    <div id="chart"></div>

    <div class="metrics">
        <div class="metric-card">
            <div class="metric-title">Всего машин за сутки</div>
            <div class="metric-value" id="total-cars">0</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Максимальное время ожидания</div>
            <div class="metric-value metric-wait" id="max-wait">0 часов</div>
        </div>
        <div class="metric-card">
            <div class="metric-title">Статус моста</div>
            <div class="metric-value" id="bridge-status">Открыт</div>
        </div>
    </div>

    <script>
        const DATA_URL = "https://raw.githubusercontent.com/nik0lya-l/bridge_parser/main/crimea_bridge.csv";

        let allData = [];
        let availableDates = [];
        let currentDate = null;

        const COLORS = {
            cars: "#00B4B4",
            wait: "#FF8C42",
            closed: "#FF6B6B",
            opened: "#51CF66"
        };

        async function loadData() {
            try {
                const response = await fetch(DATA_URL);
                if (!response.ok) {
                    throw new Error(`Ошибка HTTP! Статус: ${response.status}`);
                }
                const text = await response.text();
                return new Promise((resolve, reject) => {
                    Papa.parse(text, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            if (results.errors.length > 0) {
                                console.warn("Ошибки парсинга CSV:", results.errors);
                            }
                            if (!results.data || results.data.length === 0) {
                                reject(new Error("CSV файл не содержит данных"));
                                return;
                            }
                            const processedData = results.data
                                .filter(row => row.date && row.time)
                                .map(row => {
                                    try {
                                        const [day, month, year] = row.date.split('.');
                                        const dateObj = new Date(`${year}-${month}-${day}`);
                                        const timeParts = row.time.split(':');
                                        const hour = parseInt(timeParts[0]) || 0;
                                        const minutes = parseInt(timeParts[1]) || 0;
                                        const isClosed = row.to_crimea === "Closed";
                                        const isOpened = row.to_crimea === "Opened";
                                        
                                        return {
                                            date: dateObj,
                                            hour: hour,
                                            minutes: minutes,
                                            timeDecimal: hour + (minutes / 60),
                                            to_crimea: isClosed ? "Closed" : isOpened ? "Opened" : parseInt(row.to_crimea) || 0,
                                            from_crimea: isClosed ? "Closed" : isOpened ? "Opened" : parseInt(row.from_crimea) || 0,
                                            to_crimea_wait: isClosed || isOpened ? 0 : parseFloat(row.to_crimea_wait) || 0,
                                            from_crimea_wait: isClosed || isOpened ? 0 : parseFloat(row.from_crimea_wait) || 0,
                                            isBridgeEvent: isClosed || isOpened
                                        };
                                    } catch {
                                        return null;
                                    }
                                })
                                .filter(Boolean);
                            resolve(processedData);
                        },
                        error: (error) => {
                            reject(new Error(`Ошибка парсинга CSV: ${error.message}`));
                        }
                    });
                });
            } catch (error) {
                throw error;
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prev-date');
            const nextBtn = document.getElementById('next-date');
            const currentIndex = availableDates.indexOf(currentDate);
            prevBtn.disabled = currentIndex <= 0;
            nextBtn.disabled = currentIndex >= availableDates.length - 1;
        }

        function updateChart() {
            if (!allData || allData.length === 0) return;

            const direction = document.querySelector('input[name="direction"]:checked').value;
            const isCurrentDate = currentDate === availableDates[availableDates.length - 1];

            const dataForCurrentDate = allData.filter(item =>
                item.date.toISOString().split('T')[0] === currentDate
            );

            // Получаем события закрытия/открытия моста
            const bridgeEvents = dataForCurrentDate
                .filter(item => item.isBridgeEvent)
                .sort((a, b) => a.timeDecimal - b.timeDecimal);

            // Определяем текущий статус моста
            const lastEvent = bridgeEvents[bridgeEvents.length - 1];
            const bridgeStatus = lastEvent ? lastEvent.to_crimea : "Opened";
            document.getElementById("bridge-status").textContent = 
                bridgeStatus === "Closed" ? "Закрыт" : "Открыт";
            document.getElementById("bridge-status").style.color = 
                bridgeStatus === "Closed" ? COLORS.closed : COLORS.opened;

            let lastHour = -1;
            let lastCars = 0;
            let lastWait = 0;

            // Создаем 24 часа, с 0 по 23
            let hours = [...Array(24).keys()];

            // Если сегодня — до текущего часа, иначе 0-23
            if (isCurrentDate) {
                const now = new Date();
                lastHour = now.getHours();
                hours = hours.filter(h => h <= lastHour);
            }

            let carsArr = [];
            let waitArr = [];

            // Заполняем массивы, подставляя последний известный час при пропусках
            hours.forEach(hour => {
                const entry = dataForCurrentDate.find(d => d.hour === hour && !d.isBridgeEvent);
                if (entry) {
                    lastCars = direction === 'to_crimea' ? entry.to_crimea : entry.from_crimea;
                    lastWait = direction === 'to_crimea' ? entry.to_crimea_wait : entry.from_crimea_wait;
                }
                carsArr.push(lastCars);
                waitArr.push(lastWait);
            });

            // Формируем подписи оси X в формате "HH:00"
            const xLabels = hours.map(h => h.toString().padStart(2, '0') + ":00");

            // Создаем массив для вертикальных линий и областей закрытия
            const shapes = [];
            const annotations = [];
            let prevEvent = null;
            
            bridgeEvents.forEach((event, index) => {
                // Добавляем вертикальную линию
                shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: event.timeDecimal,
                    x1: event.timeDecimal,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: event.to_crimea === 'Closed' ? COLORS.closed : COLORS.opened,
                        width: 2,
                        dash: 'solid'
                    },
                    opacity: 0.7,
                    layer: 'below'
                });

                // Добавляем подпись
                annotations.push({
                    x: event.timeDecimal,
                    y: 1,
                    xref: 'x',
                    yref: 'paper',
                    text: event.to_crimea === 'Closed' ? 'Закрытие' : 'Открытие',
                    showarrow: false,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: event.to_crimea === 'Closed' ? COLORS.closed : COLORS.opened,
                    borderwidth: 1,
                    borderpad: 2,
                    font: {
                        size: 12,
                        color: event.to_crimea === 'Closed' ? COLORS.closed : COLORS.opened
                    }
                });

                // Добавляем закрашенную область между закрытием и открытием
                if (prevEvent && prevEvent.to_crimea === "Closed") {
                    shapes.push({
                        type: 'rect',
                        xref: 'x',
                        yref: 'paper',
                        x0: prevEvent.timeDecimal,
                        x1: event.timeDecimal,
                        y0: 0,
                        y1: 1,
                        fillcolor: 'rgba(255, 0, 0, 0.1)',
                        line: {
                            width: 0
                        },
                        layer: 'below'
                    });
                }
                
                prevEvent = event;
            });

            // Если последнее событие было закрытие, добавляем область до конца дня
            if (prevEvent && prevEvent.to_crimea === "Closed") {
                shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: prevEvent.timeDecimal,
                    x1: Math.max(...hours) + 1,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(255, 0, 0, 0.1)',
                    line: {
                        width: 0
                    },
                    layer: 'below'
                });
            }

            // Строим график с двумя осями Y
            const plotData = [
                {
                    x: xLabels,
                    y: carsArr,
                    name: "Машины",
                    type: "scatter",
                    mode: "lines+markers",
                    marker: { color: COLORS.cars },
                    line: { color: COLORS.cars },
                    yaxis: "y1",
                    hovertemplate: '%{y} машин<br>%{x}<extra></extra>'
                },
                {
                    x: xLabels,
                    y: waitArr,
                    name: "Время ожидания (ч)",
                    type: "scatter",
                    mode: "lines+markers",
                    marker: { color: COLORS.wait },
                    line: { color: COLORS.wait, dash: 'dot' },
                    yaxis: "y2",
                    hovertemplate: '%{y:.2f} ч.<br>%{x}<extra></extra>'
                }
            ];

            const layout = {
                title: `Движение ${direction === 'to_crimea' ? 'в Крым' : 'из Крыма'} за ${formatDateDisplay(currentDate)}`,
                xaxis: {
                    title: "Время (часы)",
                    tickangle: -45,
                    tickmode: "array",
                    tickvals: xLabels,
                    tickfont: { size: 12 },
                    showgrid: false,
                    zeroline: false
                },
                yaxis: {
                    title: "Количество машин",
                    side: "left",
                    showgrid: true,
                    zeroline: true,
                    zerolinewidth: 1,
                    zerolinecolor: "#ddd",
                    rangemode: "tozero"
                },
                yaxis2: {
                    title: "Время ожидания (часы)",
                    side: "right",
                    overlaying: "y",
                    showgrid: false,
                    zeroline: false,
                    rangemode: "tozero"
                },
                legend: {
                    x: 0,
                    y: 1.15,
                    orientation: "h",
                    font: { size: 14 }
                },
                margin: {
                    t: 60,
                    b: 100,
                    l: 70,
                    r: 70
                },
                hovermode: "x unified",
                plot_bgcolor: '#fff',
                paper_bgcolor: '#fff',
                font: { family: 'Arial, sans-serif', size: 14, color: '#333' },
                shapes: shapes,
                annotations: annotations
            };

            Plotly.newPlot('chart', plotData, layout, {responsive: true, displayModeBar: false});

            // Обновляем метрики под графиком
            updateMetrics(dataForCurrentDate, direction);
        }

        function updateMetrics(data, direction) {
            if (!data || data.length === 0) {
                document.getElementById("total-cars").textContent = "Нет данных";
                document.getElementById("max-wait").textContent = "Нет данных";
                return;
            }

            // Фильтруем только данные о движении (исключаем события закрытия/открытия)
            const trafficData = data.filter(item => !item.isBridgeEvent);
            
            // Считаем сумму машин за сутки
            const totalCars = trafficData.reduce((sum, item) => {
                const cars = direction === 'to_crimea' ? item.to_crimea : item.from_crimea;
                return sum + (typeof cars === 'number' ? cars : 0);
            }, 0);

            // Максимальное время ожидания (округляем до двух знаков)
            const maxWaitRaw = Math.max(...trafficData.map(item => {
                const wait = direction === 'to_crimea' ? item.to_crimea_wait : item.from_crimea_wait;
                return typeof wait === 'number' ? wait : 0;
            }));
            const maxWait = maxWaitRaw ? maxWaitRaw.toFixed(2) : "0";

            document.getElementById("total-cars").textContent = totalCars.toLocaleString('ru-RU');
            document.getElementById("max-wait").textContent = `${maxWait} часов`;
        }

        function formatDateDisplay(dateStr) {
            const d = new Date(dateStr);
            const day = d.getDate().toString().padStart(2, '0');
            const month = (d.getMonth() + 1).toString().padStart(2, '0');
            const year = d.getFullYear();
            return `${day}.${month}.${year}`;
        }

        function updateDatePicker(dateStr) {
            const dateInput = document.getElementById("date-picker");
            dateInput.value = dateStr;
        }

        function initAvailableDates(data) {
            const dateSet = new Set(data.map(d => d.date.toISOString().split('T')[0]));
            availableDates = Array.from(dateSet).sort();
        }

        function initControls() {
            const directionRadios = document.querySelectorAll('input[name="direction"]');
            directionRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    updateChart();
                });
            });

            const dateInput = document.getElementById("date-picker");
            dateInput.min = availableDates[0];
            dateInput.max = availableDates[availableDates.length - 1];

            dateInput.addEventListener('change', () => {
                if (availableDates.includes(dateInput.value)) {
                    currentDate = dateInput.value;
                    updateNavigationButtons();
                    updateChart();
                } else {
                    alert("Данные за выбранную дату недоступны.");
                    dateInput.value = currentDate;
                }
            });

            document.getElementById("prev-date").addEventListener('click', () => {
                let idx = availableDates.indexOf(currentDate);
                if (idx > 0) {
                    currentDate = availableDates[idx - 1];
                    updateDatePicker(currentDate);
                    updateNavigationButtons();
                    updateChart();
                }
            });

            document.getElementById("next-date").addEventListener('click', () => {
                let idx = availableDates.indexOf(currentDate);
                if (idx < availableDates.length - 1) {
                    currentDate = availableDates[idx + 1];
                    updateDatePicker(currentDate);
                    updateNavigationButtons();
                    updateChart();
                }
            });
        }

        async function init() {
            try {
                allData = await loadData();
                if (allData.length === 0) {
                    document.body.innerHTML = `<div class="error-message">Данные не загружены или отсутствуют.</div>`;
                    return;
                }
                initAvailableDates(allData);

                currentDate = availableDates[availableDates.length - 1];

                updateDatePicker(currentDate);
                initControls();
                updateNavigationButtons();
                updateChart();

            } catch (error) {
                document.body.innerHTML = `<div class="error-message">Ошибка загрузки данных: ${error.message}</div>`;
            }
        }

        init();
    </script>
</body>
</html>
